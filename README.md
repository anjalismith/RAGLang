# RAGLang: A Programming Language for Retrieval-Augmented Generation
Developed by Anjali Smith (**as6467**) and Shreeya Patel (**sjp2236**) for COMS4115: PLT Programming Assignment 1 

## Overview
RAGLang (Retrieval-Augmented Generation Language) is a programming language that combines structured data retrieval (using SQL-like queries) with natural language to output a prompt that can be sent to large language models (LLMs) for Retrieval-Augmented Generation tasks. 

## [RAGLang Lexer](lexer/README.md)
To execute our script, run the following commands:
1. `cd lexer`
2. `python3 run.py`.

## RAGLang Parser
If you have Python installed, you can execute our script by running the following command:

```python3 run.py.```


Otherwise, if you don't have Python installed, we have set up a Dockerfile. Use the following instructions to build and run the Docker container:
1. Install Docker Desktop from Docker's official website.
2. In the root directory, run
```docker build -t raglang-parser .```
3. Once its built, run the container with:
```docker run --rm raglang-parser```

### 1. RagLang Grammar
```Program -> RQG
R -> "RETRIEVE" Colon Source
Source -> "SOURCE" Colon String
Q -> "QUERY" Colon "SELECT" A "FROM" Identifier W L
W -> "WHERE" D Semicolon | Semicolon
L -> "LIMIT" Colon Number | epsilon
A -> List | "*"
List -> Identifier | Identifier Comma List
D -> Condition ("AND | OR") D | Condition
Condition -> Identifier Operator Value
Value -> String | Number
G -> "GENERATE" Colon Prompt
Prompt -> "PROMPT" Colon String
```

### 2. Parsing Algorithm
**Implementation and Logic Details**

Our parser follows a recursive descent parsing approach. It begins at the Program non-terminal and attempts to match each token with our defined grammar rules.

The Parser class is initialized with a list of tokens generated by a Lexer.
It maintains a position (`self.pos`) that points to the current token, which is incremented every time we successfully match a token.

The match method checks if the current token matches the expected type and optionally, an expected value. If it matches, it advances to the next token. If it doesnâ€™t match, it raises a SyntaxError.

The parse method is the main entry point to initiate parsing, starting with a call to `program()`. If parsing completes without error, it returns the AST root node for the entire parsed program. If any syntax error occurs, it catches it and returns None.

The`program()` method is designed to handle the top-level structure. It creates an ASTNode labeled "Program" and calls subparsers for each part (`r`, `q`, and `g`), which represent the retrieve command, the query command, and the generate command, respectively.

Each subparser represents a non-terminal in the grammar, defining different sections of the syntax. For example, `r()` handles the retrieve command syntax, while `q()` and `g()` handle query and generate command syntax.

Each function like `r`, `q`, `w`, `l`, `a`, and `g` represents specific grammar rules. They add structure to the AST by creating nodes based on the rule they parse.

For example, the `r()` Method.
The `r()` method parses the `RETRIEVE: SOURCE: "source_name"` command.
It matches tokens in sequence: first checking for the `RETRIEVE` keyword, followed by a colon, then `SOURCE`, another colon, and finally a string representing the source name.
Each matched element is added to the `retrieve_node` as a child, creating an AST node for the retrieve command.
Similar logic is applied to the other nonterminal grammar rule functions

In the SQL portion of RAGLang, we have a few nuances that are taken into account. 
Firstly, we have conditions. 
The `d()` method parses conditions in the `WHERE` clause. Conditions can have logical operators `(AND, OR)`, and d() builds these using a recursive structure where each condition is linked by an operator.
Each condition consists of an identifier, an `operator (e.g., >, =)`, and a value (number or string), which condition() handles.
Optional elements like `WHERE` and `LIMIT` are handled using conditional checks based on the current token at `self.pos`. 
For example, `w()` will only parse a `WHERE` clause if the keyword `WHERE` is present.
Similarly, `l()` parses a `LIMIT` clause if the `LIMIT` keyword is found.
This allows the parser to handle optional elements and epsilon (empty) productions effectively as specified in the grammar. 

**Error Handling**

If any token does not match the expected type or value, a `SyntaxError` is raised with details about what was expected.

Since this is a top-down parser, it does not use explicit backtracking and more so relies on recursive calls and matching to enforce our specified grammar structure.

**Resulting AST**

The ASTNode objects are built hierarchically in our implementation.
Our AST removes redundancy by abstracting away syntax details like extra keywords and only including relevant operations and clauses.


### 3. Sample Input Programs

#### Sample Input 1 - Testing SELECT syntax with list of columns, limit syntax, and a complex WHERE clause
* Input:
```
RETRIEVE:
    SOURCE: "SalesDB.json"
    QUERY: SELECT product, total_sales FROM sales_data WHERE year = "2023" AND region = "North America";
    LIMIT: 5
GENERATE:
    PROMPT: "Summarize the top-performing products in a brief report highlighting key sales figures and top products"
```
* Lexer Output (Tokenization):
```
[('KEYWORD', 'RETRIEVE'), ('COLON', ':'), ('KEYWORD', 'SOURCE'), ('COLON', ':'), ('STRING', 'SalesDB.json'), ('KEYWORD', 'QUERY'), ('COLON', ':'), ('KEYWORD', 'SELECT'), ('IDENTIFIER', 'product'), ('COMMA', ','), ('IDENTIFIER', 'total_sales'), ('KEYWORD', 'FROM'), ('IDENTIFIER', 'sales_data'), ('KEYWORD', 'WHERE'), ('IDENTIFIER', 'year'), ('OPERATOR', '='), ('STRING', '2023'), ('KEYWORD', 'AND'), ('IDENTIFIER', 'region'), ('OPERATOR', '='), ('STRING', 'North America'), ('SEMICOLON', ';'), ('KEYWORD', 'LIMIT'), ('COLON', ':'), ('NUMBER', '5'), ('KEYWORD', 'GENERATE'), ('COLON', ':'), ('KEYWORD', 'PROMPT'), ('COLON', ':'), ('STRING', 'Summarize the top-performing products in a brief report highlighting key sales figures and top products')]
```
* Parser Output (AST):
```
'Program'
        'R'
                'Keyword': 'RETRIEVE'
                'Source'
                        'Keyword': 'SOURCE'
                        'String': 'SalesDB.json'
        'Q'
                'Keyword': 'QUERY'
                'Keyword': 'SELECT'
                'A'
                        'List'
                                'Identifier': 'product'
                                'Identifier': 'total_sales'
                'Keyword': 'FROM'
                'Identifier': 'sales_data'
                'Where'
                        'Keyword': 'WHERE'
                        'D'
                                'Condition'
                                        'Identifier': 'year'
                                        'Operator': '='
                                        'Value': '2023'
                                'Keyword': 'AND'
                                'Condition'
                                        'Identifier': 'region'
                                        'Operator': '='
                                        'Value': 'North America'
                'L'
                        'Keyword': 'LIMIT'
                        'Number': '5'
        'G'
                'Keyword': 'GENERATE'
                'Prompt'
                        'Keyword': 'PROMPT'
                        'String': 'Summarize the top-performing products in a brief report highlighting key sales figures and top products

```

#### Sample Input 2 - Testing complex query with the use of the * operator in the SELECT clause
* Input: 
```
RETRIEVE:
    SOURCE: "InventoryDB.json" 
    QUERY: SELECT * FROM products WHERE stock > 50 AND category = "electronics";
    LIMIT: 20 
GENERATE: 
    PROMPT: "List all products with sufficient stock and catchy slogans for each product that we can use on our company social media"
```

* Lexer Output (Tokenization):
```
[('KEYWORD', 'RETRIEVE'), ('COLON', ':'), ('KEYWORD', 'SOURCE'), ('COLON', ':'), ('STRING', 'InventoryDB.json'), ('KEYWORD', 'QUERY'), ('COLON', ':'), ('KEYWORD', 'SELECT'), ('OPERATOR', '*'), ('KEYWORD', 'FROM'), ('IDENTIFIER', 'products'), ('KEYWORD', 'WHERE'), ('IDENTIFIER', 'stock'), ('OPERATOR', '>'), ('NUMBER', '50'), ('KEYWORD', 'AND'), ('IDENTIFIER', 'category'), ('OPERATOR', '='), ('STRING', 'electronics'), ('SEMICOLON', ';'), ('KEYWORD', 'LIMIT'), ('COLON', ':'), ('NUMBER', '20'), ('KEYWORD', 'GENERATE'), ('COLON', ':'), ('KEYWORD', 'PROMPT'), ('COLON', ':'), ('STRING', 'List all products with sufficient stock and catchy slogans for each product that we can use on our company social media')]
```
* Parser Output (AST):
```
'Program'
        'R'
                'Keyword': 'RETRIEVE'
                'Source'
                        'Keyword': 'SOURCE'
                        'String': 'InventoryDB.json'
        'Q'
                'Keyword': 'QUERY'
                'Keyword': 'SELECT'
                'A'
                        'Operator': '*'
                'Keyword': 'FROM'
                'Identifier': 'products'
                'Where'
                        'Keyword': 'WHERE'
                        'D'
                                'Condition'
                                        'Identifier': 'stock'
                                        'Operator': '>'
                                        'Value': '50'
                                'Keyword': 'AND'
                                'Condition'
                                        'Identifier': 'category'
                                        'Operator': '='
                                        'Value': 'electronics'
                'L'
                        'Keyword': 'LIMIT'
                        'Number': '20'
        'G'
                'Keyword': 'GENERATE'
                'Prompt'
                        'Keyword': 'PROMPT'
                        'String': 'List all products with sufficient stock and catchy slogans for each product that we can use on our company social media'
```

### Sample Input 3 - Testing syntax error due to missing semicolon in WHERE clause
```
RETRIEVE: 
    SOURCE: "Sales.json" 
    QUERY: SELECT product_id FROM sales_data WHERE quantity > 10
    LIMIT: 5 
GENERATE:
    PROMPT: "Summarize sales data to generate a motivational message that I can use to deliver to our salespeople for their hardwork this quarter."
```
Lexer Output:
```
[('KEYWORD', 'RETRIEVE'), ('COLON', ':'), ('KEYWORD', 'SOURCE'), ('COLON', ':'), ('STRING', 'Sales.json'), ('KEYWORD', 'QUERY'), ('COLON', ':'), ('KEYWORD', 'SELECT'), ('IDENTIFIER', 'product_id'), ('KEYWORD', 'FROM'), ('IDENTIFIER', 'sales_data'), ('KEYWORD', 'WHERE'), ('IDENTIFIER', 'quantity'), ('OPERATOR', '>'), ('NUMBER', '10'), ('KEYWORD', 'LIMIT'), ('COLON', ':'), ('NUMBER', '5'), ('KEYWORD', 'GENERATE'), ('COLON', ':'), ('KEYWORD', 'PROMPT'), ('COLON', ':'), ('STRING', 'Summarize sales data to generate a motivational message that I can use to deliver to our salespeople for their hardwork this quarter.')]
```
Parser Output:
```
Syntax error: Expected SEMICOLON ';' at position 15
AST: None
```

### Sample Input 4 - Testing syntax error due to missing colon after RETRIEVE

```
RETRIEVE
    SOURCE: "Analytics.json" 
    QUERY: SELECT region FROM demographics WHERE age > 18;
    LIMIT: 10 
GENERATE: 
    PROMPT: "Provide a summary of regional demographics and turn it into an abstract for our report"
```
Lexer Output:
```
[('KEYWORD', 'RETRIEVE'), ('KEYWORD', 'SOURCE'), ('COLON', ':'), ('STRING', 'Analytics.json'), ('KEYWORD', 'QUERY'), ('COLON', ':'), ('KEYWORD', 'SELECT'), ('IDENTIFIER', 'region'), ('KEYWORD', 'FROM'), ('IDENTIFIER', 'demographics'), ('KEYWORD', 'WHERE'), ('IDENTIFIER', 'age'), ('OPERATOR', '>'), ('NUMBER', '18'), ('SEMICOLON', ';'), ('KEYWORD', 'LIMIT'), ('COLON', ':'), ('NUMBER', '10'), ('KEYWORD', 'GENERATE'), ('COLON', ':'), ('KEYWORD', 'PROMPT'), ('COLON', ':'), ('STRING', 'Provide a summary of regional demographics and turn it into an abstract for our report')]
```

Parser Output: 
```
Syntax error: Expected COLON ':' at position 1
AST: None
```

### Sample Input 5 - Testing syntax error due to missing QUERY keyword

```
RETRIEVE: 
    SOURCE: "CustomerDB.json" 
    SELECT customer_id, purchase_amount FROM transactions WHERE purchase_amount > 100 AND loyalty_status = "Gold";
GENERATE: 
    PROMPT: "Summarize high-value transactions"
```
Lexer Output: 
```
[('KEYWORD', 'RETRIEVE'), ('COLON', ':'), ('KEYWORD', 'SOURCE'), ('COLON', ':'), ('STRING', 'CustomerDB.json'), ('KEYWORD', 'SELECT'), ('IDENTIFIER', 'customer_id'), ('COMMA', ','), ('IDENTIFIER', 'purchase_amount'), ('KEYWORD', 'FROM'), ('IDENTIFIER', 'transactions'), ('KEYWORD', 'WHERE'), ('IDENTIFIER', 'purchase_amount'), ('OPERATOR', '>'), ('NUMBER', '100'), ('KEYWORD', 'AND'), ('IDENTIFIER', 'loyalty_status'), ('OPERATOR', '='), ('STRING', 'Gold'), ('SEMICOLON', ';'), ('KEYWORD', 'GENERATE'), ('COLON', ':'), ('KEYWORD', 'PROMPT'), ('COLON', ':'), ('STRING', 'Summarize high-value transactions')]
```
Parser Output:
```
Syntax error: Expected KEYWORD 'QUERY' at position 5
AST: None
```

### 4. Shell Script
If you have Python installed, you can execute our script by running the following command:

```python3 run.py.```


Otherwise, if you don't have Python installed, we have set up a Dockerfile. Use the following instructions to build and run the Docker container:
1. Install Docker Desktop from Docker's official website.
2. In the root directory, run
```docker build -t raglang-parser .```
3. Once its built, run the container with:
```docker run --rm raglang-parser```

This will run our parser algorithm on our 5 input programs - 2 of which succeed and 3 of which have syntatic errors.

Each program simulates a query with commands like RETRIEVE, QUERY, and GENERATE, using different data sources and prompts. After receiving the tokens from the lexer, the parser matches each token according to the specified context free grammar and outputs an abstract syntax tree representation of the input. 


### 5. Video






